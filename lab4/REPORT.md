#№ Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Медведев Д.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|     з        |      26.04    |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Обработка искусственных и особенно естественных языков (NLP) является актуальной задачей в настоящее время. При обработке таких языков
используются алгоритмы машинного обучения. В целом, есть 2 метода обработки естественного языка: статистический и лингвистический. 
В основе статистического подхода лежит предположение, что содержание текста отражается наиболее часто встречающимися словами. 
Главный недостаток статистических методов состоит в невозможности учёта связности текста. Эту проблему решает лингвистический метод,
который разбивается на уровни и помогает учитывать связи между словами и предложениями.
 
Язык логического программирования Prolog оказывается удобным языком для решения таких задач, так как он основан на переборе вариантов,
в виде которых можно представить грамматику естественного языка (факты и правила).

## Задание

3. Реализовать синтаксический анализатор арифметического выражения и вычислить его числовое значение. 
В выражении допустимы операции +, -, *, /, степень ^. Учитывать приоритеты операций.

```
Запрос:     ?- calculate([5, ‘+’, 3, ‘^’,2], X).
Результат:  X=14.
```

## Принцип решения

Очень удобно решать задачу подсчета арифметического выражения рекурсивно. Находим операцию минимальную по приоритету (-, +, *, /, ^). 
Через предикат append делим наш список на то, что было до операции - A и после - B. Далее этот же предикат запускаем для A и B. 
В итоге мы дойдем до операций с максимальным приоритетом, которые глубже, посчитаем их значение, вернемся и т.д., пока полностью не 
выйдем из рекурсии и не получим искомое число - значение исходного выражения.

```prolog
calculate([N], N) :- number(N).
calculate(Seq, Ans) :- append(A, ['-'|B], Seq), calculate(A, X), calculate(B, Y), !, Ans is X - Y.
calculate(Seq, Ans) :- append(A, ['+'|B], Seq), calculate(A, X), calculate(B, Y), !, Ans is X + Y.
calculate(Seq, Ans) :- append(A, ['*'|B], Seq), calculate(A, X), calculate(B, Y), !, Ans is X * Y.
calculate(Seq, Ans) :- append(A, ['/'|B], Seq), calculate(A, X), calculate(B, Y), !, Y \= 0, Ans is X / Y.
calculate(Seq, Ans) :- append(A, ['^'|B], Seq), calculate(A, X), calculate(B, Y), !, Ans is X ** Y.
```

## Результаты

```prolog
?- calculate([3, '*', 2, '^', 3], X).
X = 24.

?- calculate([3, '^', 2, '^', 3], X).
X = 6561.

?- calculate([3, '+', 9, '/', 3, '*', 6, '^', 2, '-', 1], X).
X = 110.

?- calculate([3, '+', 9, '/', 0], X).
false.
```

## Выводы

Таким образом, данная работа показала мне, что Prolog является легким инструментом для подсчета арифметического выражения. Такая же
задача решается на языках императивного программирования с помощью алгоритма Дейкстры (сортировочной станции), и кода там намного 
больше, чем на Prolog. Также благодаря этой работе я уверенно научился пользоваться рекурсией в Prolog. В итоге, Prolog является
прекрасным инструментом для решения задач грамматического разбора из-за своей компактности, внутреннего устройства и парадигмы 
программирования.   



